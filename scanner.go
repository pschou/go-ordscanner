package ordscanner

import (
	"bufio"
	"bytes"
)

type Scanner struct {
	scns []*bufio.Scanner
	err  error
	cur  int
}

// Text returns the most recent token generated by a call to Scanner.Scan as a
// newly allocated string holding its bytes.
func (s *Scanner) Text() string {
	if len(s.scns) == 0 {
		return ""
	}
	if s.cur < 0 {
		s.ord()
	}
	return s.scns[s.cur].Text()
}

// Bytes returns the most recent token generated by a call to Scanner.Scan. The
// underlying array may point to data that will be overwritten by a subsequent
// call to Scan. It does no allocation.
func (s *Scanner) Bytes() []byte {
	if len(s.scns) == 0 {
		return nil
	}
	if s.cur < 0 {
		s.ord()
	}
	return s.scns[s.cur].Bytes()
}

// Scan advances the Scanner to the next token, which will then be available
// through the Scanner.Bytes or Scanner.Text method. It returns false when
// there are no more tokens, either by reaching the end of the input or an
// error.
func (s *Scanner) Scan() bool {
	if s.err != nil || len(s.scns) == 0 {
		return false
	}

	if s.cur < 0 {
		// Populate the initial scan on all the inputs
		list := s.scns
		s.scns = nil
		for _, scn := range list {
			if scn.Scan() {
				s.scns = append(s.scns, scn)
			} else {
				s.err = scn.Err()
				if s.err != nil {
					return false
				}
			}
		}
	} else {
		// Call scan on the last scan used, remove from list if used
		if !s.scns[s.cur].Scan() {
			s.err = s.scns[s.cur].Err()
			if s.err != nil {
				s.cur = -1
				return false
			}
			s.scns = append(s.scns[:s.cur], s.scns[s.cur+1:]...)
		}
		if len(s.scns) == 0 {
			return false
		}
	}

	s.ord()
	return true
}

func (s *Scanner) ord() {
	// Find the next ordered scan
	comp := s.scns[0].Bytes()
	s.cur = 0
	for i, scn := range s.scns[1:] {
		if b := scn.Bytes(); bytes.Compare(comp, b) >= 0 {
			s.cur = i + 1
			comp = b
		}
	}
}

// NewScanner returns a new Scanner to read from a set of scanners which expect
// ordered input.
func New(list ...*bufio.Scanner) *Scanner {
	return &Scanner{cur: -1, scns: list}
}
